<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-pikachu.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-pikachu.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="-QMh-gRPduq5T_vg3_Pwi3kZsNSiyuEpPBaDIXV8J34">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oscarcx123.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="《现代操作系统》第一章自学笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Modern Operating Systems Intro">
<meta property="og:url" content="https://oscarcx123.github.io/tech/modern-operating-systems-intro.html">
<meta property="og:site_name" content="Azure">
<meta property="og:description" content="《现代操作系统》第一章自学笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/MULTICS_timeline.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/1998924_20130219075643.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/gs88_071.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_17.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_20.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_22.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_24.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_26.png">
<meta property="og:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_30.png">
<meta property="article:published_time" content="2020-03-10T21:19:05.000Z">
<meta property="article:modified_time" content="2020-10-23T05:45:14.752Z">
<meta property="article:author" content="oscarcx123">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_1.png">

<link rel="canonical" href="https://oscarcx123.github.io/tech/modern-operating-systems-intro.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Modern Operating Systems Intro | Azure</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <link rel="stylesheet" href="/aplayer/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/aplayer/APlayer.min.js"></script>
  <script type="text/javascript" src="/aplayer/music.js"></script>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Azure</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oscarcx123.github.io/tech/modern-operating-systems-intro.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="oscarcx123">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Azure">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Modern Operating Systems Intro
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-10 17:19:05" itemprop="dateCreated datePublished" datetime="2020-03-10T17:19:05-04:00">2020-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tech/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>《现代操作系统》第一章自学笔记</p>
<a id="more"></a>

<p>操作系统（Operating System）</p>
<ul>
<li>主流系统：Windows, Linux, FreeBSD, OS X</li>
<li>交互（interface）方式：<ul>
<li>shell</li>
<li>GUI（Graphical User Interface）</li>
<li>运行在用户态最底层，可以启动其它程序（例如浏览器）</li>
</ul>
</li>
<li>运行模式：<ul>
<li>内核态（kernel mode / supervisor mode）<ul>
<li>操作系统运行在内核态</li>
<li>可以执行任意指令</li>
<li>对硬件有完整控制权</li>
</ul>
</li>
<li>用户态（user mode）<ul>
<li>其它软件都运行在用户态</li>
<li>只能执行部分指令（例如无法进行I/O）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_1.png" alt=""></p>
<p>普通软件可以随意替换重写，但是操作系统的组件，例如时钟中断处理程序（clock interrupt handler），就不可更改或重写，因为此程序受硬件保护。嵌入式系统(embedded systems)（没有内核态）和解释系统(intepreted systems)（非硬件方式区分组件）可能不受此规则约束。</p>
<p>操作系统的进化：</p>
<ul>
<li>Windows<ul>
<li>Windows 95/98/Me</li>
<li>Windows NT/2000/XP/Vista/Windows 7</li>
<li>两条线完全不一样，只是UI看起来相似</li>
</ul>
</li>
<li>UNIX系<ul>
<li>System V, Solaris, FreeBSD（来源于UNIX）</li>
<li>Linux（从UNIX依葫芦画瓢得来）</li>
</ul>
</li>
</ul>
<h1 id="What-is-an-Operating-System"><a href="#What-is-an-Operating-System" class="headerlink" title="What is an Operating System?"></a>What is an Operating System?</h1><p>操作系统有两大功能：</p>
<ul>
<li>提供清晰易用的硬件资源管理方法（provide clean abstract set of resources）</li>
<li>管理硬件资源（manage these hardware resources）</li>
</ul>
<h2 id="The-Operating-System-as-an-Extended-Machine"><a href="#The-Operating-System-as-an-Extended-Machine" class="headerlink" title="The Operating System as an Extended Machine"></a>The Operating System as an Extended Machine</h2><p>计算机底层是相当原始的，通过抽象化（abstraction）提升易用性，以SATA(Serial ATA)硬盘为例：</p>
<ul>
<li>最初是超过450页的说明文档</li>
<li>然后是硬盘驱动（disk driver），提供读写硬盘块接口</li>
<li>最后是操作系统提供的文件系统</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_2.png" alt=""></p>
<h2 id="The-Operating-System-as-a-Resource-Manager"><a href="#The-Operating-System-as-a-Resource-Manager" class="headerlink" title="The Operating System as a Resource Manager"></a>The Operating System as a Resource Manager</h2><p>多路复用（multiplexing）</p>
<ul>
<li>时间上复用（time）<ul>
<li>不同用户或程序轮流使用资源</li>
<li>队列管理以及使用时长由操作系统决定</li>
<li>例子：多个程序在一个CPU上跑，打印队列</li>
</ul>
</li>
<li>空间上复用（space）<ul>
<li>不同用户或程序取得部分资源</li>
<li>例子：内存，硬盘</li>
</ul>
</li>
</ul>
<h1 id="History-of-Operating-Systems"><a href="#History-of-Operating-Systems" class="headerlink" title="History of Operating Systems"></a>History of Operating Systems</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87">Charles Babbage</a> (1792–1871)提出了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86%E6%A9%9F">差分机</a>，是计算机先驱</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%84%9B%E9%81%94%C2%B7%E5%8B%92%E8%8A%99%E8%95%BE%E7%B5%B2">Ada Lovelace</a>是世界上第一个程序员</p>
<h2 id="Gen-1-1945–55-Vacuum-Tubes"><a href="#Gen-1-1945–55-Vacuum-Tubes" class="headerlink" title="Gen 1 (1945–55): Vacuum Tubes"></a>Gen 1 (1945–55): Vacuum Tubes</h2><ul>
<li>电脑使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E7%A9%BA%E7%AE%A1">真空管</a></li>
<li>没有编程语言（包括汇编），使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Plugboard">插线板</a>（plugboards）</li>
<li>没有操作系统</li>
<li>1950s，出现了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%93%E5%AD%94%E5%8D%A1">穿孔卡片</a>（punched cards）</li>
<li>例子：Colossus (Bletchley Park, England), Mark I (Harvard), ENIAC (UPenn)</li>
</ul>
<h2 id="Gen-2-1955–65-Transistors-and-Batch-Systems"><a href="#Gen-2-1955–65-Transistors-and-Batch-Systems" class="headerlink" title="Gen 2 (1955–65): Transistors and Batch Systems"></a>Gen 2 (1955–65): Transistors and Batch Systems</h2><p>1950s中期，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%AE%A1">晶体管</a>（transistor）被发明</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA">大型机</a>（mainframes）</p>
<ul>
<li>放在带空调的大型电脑房</li>
<li>需要专业操作员</li>
<li>数百万美元的价格，只有大公司、主要政府机构、大学才用得起</li>
</ul>
<p>运行作业（job -&gt; a program / a set of programs）的过程：</p>
<ul>
<li>在纸上写程序（用FORTRAN或者汇编）</li>
<li>穿孔成卡片</li>
<li>把卡片交给操作员</li>
<li>运行完成后，操作员会获取打印的输出</li>
</ul>
<p>因为操作员东跑西跑，很浪费时间，所以出现了批处理系统（batch system）</p>
<ul>
<li>由小型机器（例如IBM 1401）从卡片收集输入</li>
<li>积攒一定量之后，拿去大型机（如IBM 7094）计算</li>
<li>计算完成后，由小型机器（例如IBM 1401）负责打印输出内容</li>
<li>在计算机之间负责传输数据的介质是磁带（tape）</li>
</ul>
<p>输入作业的结构：</p>
<ul>
<li>$JOB card<ul>
<li>最大运行时间</li>
<li>计费账号</li>
<li>程序员名字</li>
</ul>
</li>
<li>$FORTRAN card<ul>
<li>告诉系统加载FORTRAN编译器</li>
<li>$FORTRAN card后面跟着FORTRAN程序</li>
</ul>
</li>
<li>$LOAD card<ul>
<li>让操作系统加载刚刚编译的目标程序</li>
</ul>
</li>
<li>$RUN card<ul>
<li>让操作系统运行程序并使用$RUN card后面跟着的数据</li>
</ul>
</li>
<li>$END card<ul>
<li>标志作业结束</li>
</ul>
</li>
</ul>
<p>当时主流操作系统：</p>
<ul>
<li>FMS (the Fortran Monitor System)</li>
<li>IBSYS (IBM 7094的操作系统)</li>
</ul>
<h2 id="Gen-3-1965–1980-ICs-and-Multiprogramming"><a href="#Gen-3-1965–1980-ICs-and-Multiprogramming" class="headerlink" title="Gen 3 (1965–1980): ICs and Multiprogramming"></a>Gen 3 (1965–1980): ICs and Multiprogramming</h2><p>当时有两种完全不同的产品线：</p>
<ul>
<li>负责科学计算的计算机，例如IBM 7094 -&gt; word-oriented</li>
<li>负责磁带整理和打印的计算机，例如IBM 1401 -&gt; character-oriented</li>
</ul>
<p>System/360的出现一举合并了两条产品线</p>
<ul>
<li>后续系列有370, 4300, 3080, 3090</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IBM_Z">zSeries</a>是此系列最新机型</li>
<li>首个采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF">集成电路</a>（ICs / Integrated Circuits）的主流机型，并且价格跟性能都比基于晶体管的计算机好很多</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OS/360_and_successors">OS/360</a>是System/360系列的操作系统</p>
<ul>
<li>数千个程序员写了几百万行汇编</li>
<li>因为太复杂，总是修了旧的bug又引入了新的bug，最后成了烂摊子</li>
<li>虽然坑，但是用户总体还是满意的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86">多道程序处理</a>（multiprogramming）</p>
<ul>
<li>在一个程序等待I/O的时候，另一个程序可以使用CPU，从而避免资源闲置</li>
<li>现在叫多任务处理</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%81%87%E8%84%B1%E6%9C%BA">外部设备联机并行操作</a>（spool / Simultaneous Peripheral Operation On Line）</p>
<ul>
<li>当一个作业运行完之后，可以直接从磁盘读取新作业并载入空出的内存运行</li>
<li>IBM 1401失去用武之地</li>
<li>现代例子：打印机队列</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1">分时系统</a>（timesharing）</p>
<ul>
<li>多个用户可以同时使用同一台计算机</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B8%E5%AE%B9%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1">兼容分时系统</a>（CTSS / Compatible Time Sharing System）是第一个通用的分时系统，在麻省理工开发</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://web.mit.edu/multics-history/">MULTICS</a> (MULTiplexed Information and Computing Service)</p>
<ul>
<li>著名的分时操作系统（time-sharing operating system）</li>
<li>1964年由贝尔实验室（Bell Labs）、麻省理工学院及美国通用电气公司（General Electric）所共同参与研发</li>
<li>很多用户直到1990s晚期才关闭MULTICS系统</li>
<li>在<a target="_blank" rel="noopener" href="https://www.multicians.org/">这里</a>可以找到MULTICS系统的更多信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/MULTICS_timeline.png" alt=""></p>
<p>小型机（minicomputers）的崛起：</p>
<ul>
<li>DEC PDP-1 (1961)<ul>
<li>仅售$120,000，是IBM 7094价格的5%</li>
<li>在一些非数值计算上，跟IBM 7094的速度差不多</li>
</ul>
</li>
</ul>
<p>UNIX系统在此阶段的发展</p>
<ul>
<li>IEEE制定了标准：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">POSIX / Portable Operating System Interface</a></li>
<li>System V (AT&amp;T)</li>
<li>BSD / Berkeley Software Distribution (UC Berkeley)</li>
<li>MINIX (1987) -&gt; MINIX 3<ul>
<li>是UNIX的仿制品</li>
<li>主要用于教学</li>
<li>官网<a target="_blank" rel="noopener" href="http://www.minix3.org/">在此</a>，提供免费下载</li>
</ul>
</li>
<li>Linux (inspired by MINIX)</li>
</ul>
<h2 id="Gen-4-1980–Present-Personal-Computers"><a href="#Gen-4-1980–Present-Personal-Computers" class="headerlink" title="Gen 4 (1980–Present): Personal Computers"></a>Gen 4 (1980–Present): Personal Computers</h2><p>随着大规模集成电路（LSI / Large Scale Integration circuit）的出现，PC时代到来了。PC在当时叫微机（microcomputers，微型计算机）。</p>
<ul>
<li>1974年，Intel 8080造出了第一个通用8-bit CPU<ul>
<li>Gary Kildall为这个CPU写了操作系统，叫<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CP/M">CP/M</a> (Control Program for Microcomputers)</li>
<li>Intel觉得基于磁盘的微机没前途，所以就让Gary Kildall拿到了版权</li>
<li>Gary Kildall随后开了个公司，叫Digital Research，主要开发和销售CP/M</li>
</ul>
</li>
<li>1977年，Digital Research重写了CP/M，使其能在各种CPU上面跑，例如Intel 8080，Zilog Z80等等</li>
<li>1980s，IBM设计了IBM PC，并且需要能在上面运行的软件，接下来轮到比尔盖茨表演空手套白狼~<ul>
<li>IBM找了比尔盖茨询问他的BASIC解释器</li>
<li>比尔盖茨让IBM找当时如日中天的Digital Research</li>
<li>Digital Research没理IBM，合作告吹</li>
<li>于是IBM又找比尔盖茨，这回要操作系统</li>
<li>盖茨从Seattle Computer Products那里以$75,000买了DOS (Disk Operating System)，然后加上自己的BASIC解释器一起转手给了IBM。不过盖茨没让IBM买断，而是跟IBM PC硬件捆绑销售。</li>
<li>IBM需要对DOS做一些修改，于是盖茨直接请了写DOS的人（Tim Paterson）来微软公司</li>
<li>最后这个系统叫做MS-DOS (MicroSoft Disk Operating System)</li>
</ul>
</li>
<li>1983年，IBM PC/AT搭配Intel 80286 CPU作为IBM PC的继承者横空出世<ul>
<li>这时候CP/M已经差不多要凉了</li>
<li>MS DOS越来越红火，在后来的Intel 80386 &amp; 80486 CPU上都广泛使用</li>
</ul>
</li>
<li>此时操作系统都是命令行，乔布斯从Xerox那里看到了GUI，并意识到了GUI的潜在价值，于是就推出了带GUI的电脑<ul>
<li>Lisa（由于太贵而失败）</li>
<li>Macintosh（大获成功，因为操作方式对用户友好）</li>
</ul>
</li>
<li>微软看到Macintosh的成功，于是依葫芦画瓢搞了个Windows<ul>
<li>1985-1995年，Windows只是作为MS DOS的图形界面</li>
<li>1995年，推出了Windows 95，此时MS DOS只负责启动以及运行老的DOS程序</li>
<li>1998年，推出了改进版，叫Windows 98，不过仍然包含大量16位Intel汇编</li>
</ul>
</li>
<li>Windows NT（Windows New Technology）看起来跟之前没区别，但是底层已经完全重写，是32位的系统<ul>
<li>1999年，Windows NT 5.0改名为Windows 2000，尝试完全代替Windows 98，但是没有成功</li>
<li>所以微软又推出了Windows 98的改良版，叫Windows Me (Millennium Edition)</li>
</ul>
</li>
<li>2001年，微软推出了Windows 2000的改进版，就是我们熟知的Windows XP<ul>
<li>Windows XP主要分支：<ul>
<li>客户端（client）</li>
<li>服务器端（server）</li>
<li>嵌入式系统（embedded）</li>
</ul>
</li>
<li>这些分支导致各种服务包（service packs）出现</li>
</ul>
</li>
<li>2007年，微软推出了Windows Vista<ul>
<li>微软寄予厚望，然而Windows Vista凉透了</li>
</ul>
</li>
<li>2009年，微软推出了Windows 7<ul>
<li>七个月内，Windows 7的份额就超过了Windows Vista</li>
</ul>
</li>
<li>2012年，微软推出了Windows 8<ul>
<li>书上到这里就结束了，但是实际上Windows 8又凉了</li>
</ul>
</li>
<li>2015年，微软推出了Windows 10<ul>
<li>可以从Windows 7免费升级到Windows 10</li>
</ul>
</li>
</ul>
<p>x86架构主要有两个变种：</p>
<ul>
<li>x86-32 (32-bit)</li>
<li>x86-64 (64-bit)</li>
</ul>
<p>UNIX系的GUI</p>
<ul>
<li>X Window System (X11)</li>
<li>完整的GUI是运行在X11之上的，例如Gnome, KDE</li>
</ul>
<p>网络操作系统（network operating systems）</p>
<p>分布式操作系统（distributed operating systems）</p>
<h2 id="Gen-5-1990–Present-Mobile-Computers"><a href="#Gen-5-1990–Present-Mobile-Computers" class="headerlink" title="Gen 5 (1990–Present): Mobile Computers"></a>Gen 5 (1990–Present): Mobile Computers</h2><ul>
<li>1946年，贝尔实验室造出了第一个移动电话，只不过重达40kg</li>
<li>1970s，第一个真正意义上的移动电话被造出来，只有1kg重</li>
<li>1990s中期，诺基亚造出了N9000，是手机和PDA(Personal Digital Assistant)的结合体</li>
<li>1997年，爱立信造出了第一个概念智能手机GS88 “Penelope”，不过只有原型机，最后没有公开发售。图片取自<a target="_blank" rel="noopener" href="https://ericssoners.wordpress.com/2016/06/13/gs88/">这篇介绍GS88的文章</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/1998924_20130219075643.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/gs88_071.jpg" alt=""></p>
<p>手机操作系统有：</p>
<ul>
<li>Symbian OS (Nokia, 1998年)<ul>
<li>主要厂商：诺基亚，三星，索尼爱立信，摩托罗拉</li>
</ul>
</li>
<li>Blackberry OS (<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%BB%91%E8%8E%93%E5%85%AC%E5%8F%B8">RIM / BlackBerry</a>, 2002年)</li>
<li>iOS (Apple, 2007年)<ul>
<li>随着第一代iPhone一起发布</li>
</ul>
</li>
<li>Android (Google, 2008年)<ul>
<li>基于Linux，开源</li>
</ul>
</li>
<li>Windows Phone (Microsoft, 2010年)<ul>
<li>已经凉了</li>
</ul>
</li>
</ul>
<h1 id="Computer-Hardware-Review"><a href="#Computer-Hardware-Review" class="headerlink" title="Computer Hardware Review"></a>Computer Hardware Review</h1><p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_6.png" alt=""></p>
<h2 id="Processors"><a href="#Processors" class="headerlink" title="Processors"></a>Processors</h2><p>关于计算机的“大脑”CPU：</p>
<ul>
<li>CPU的基本周期（basic cycle）：<ul>
<li>从内存取出指令（fetch instruction）</li>
<li>解码以确定类型和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%8B%E7%AE%97%E6%95%B8">操作数</a>（decode type and operands）</li>
<li>执行指令（execute）</li>
</ul>
</li>
<li>指令集（Instruction set）<ul>
<li>x86</li>
<li>ARM</li>
<li>CPU只能执行自己架构的指令</li>
</ul>
</li>
<li>寄存器（registers）<ul>
<li>通用寄存器（general registers）<ul>
<li>储存关键变量（key variables）和临时数据（temporary results）</li>
<li>因为访问内存获取指令或者数据很花时间，所以通常会有指令从内存加载到寄存器，反之亦然。</li>
</ul>
</li>
<li>特殊寄存器（special registers）<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%88%E6%95%B8%E5%99%A8">程序计数器</a>（program counter）<ul>
<li>保存了下一条指令的地址</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack_register">堆栈指针</a>（stack pointer）<ul>
<li>指向内存中当前栈的顶端</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AD%97">程序状态字</a>（PSW / Program Status Word）<ul>
<li>包含了条件码位（condition code bits）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>流水线（pipeline）技术<ul>
<li>现代CPU一个周期可以执行多条指令</li>
<li>指令一旦被获取就必须执行完</li>
</ul>
</li>
<li>超标量（superscalar）架构<ul>
<li>多个执行单位<ul>
<li>整数运算（integer arithmetic）</li>
<li>浮点数运算（floating-point arithmetic）</li>
<li>布尔运算（boolean operation）</li>
</ul>
</li>
<li>多条指令被同时获取并解码，然后存放到缓冲区（holding buffer）</li>
<li>一旦执行单位空闲，就会到缓冲区查看是否有能执行的指令</li>
<li>副作用：程序的指令经常不按顺序执行</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_7.png" alt=""></p>
<h3 id="Multithreaded-and-Multicore-Chips"><a href="#Multithreaded-and-Multicore-Chips" class="headerlink" title="Multithreaded and Multicore Chips"></a>Multithreaded and Multicore Chips</h3><p>摩尔定律（Moore’s law）：芯片中晶体管的数量每十八个月翻一番（the number of transistors on a chip doubles every 18 months）</p>
<p>多线程（multithreading）/ 超线程（hyperthreading）</p>
<ul>
<li>SPARC, Power5, Intel Xeon, Intel Core都支持多线程</li>
<li>允许CPU保持两个线程的状态，并且可以在纳秒级的时间内来回切换</li>
<li>不是真正的并行处理，一次只有一个进程在跑</li>
<li>每个线程在操作系统看来就是一个CPU核心，所以双核四线程看起来就是四核</li>
</ul>
<p>CPU核心（core）</p>
<ul>
<li>每个核心都是完整的处理器</li>
<li>Intel Xeon Phi和Tilera TilePro等CPU，已经超过60核</li>
<li>GPU (Graphics Processing Unit)核心更多，有数以千计的微核，擅长大量简单的并行运算</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_8.png" alt=""></p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>又快又大还便宜的内存是不存在的~</p>
<p>内存系统采用分层结构：</p>
<ul>
<li>CPU内部的寄存器（最快）<ul>
<li>32-bit的CPU上的储存空间是32*32 bits(=0.128KB)</li>
<li>64-bit的CPU上的储存空间是64*64 bits(=0.512KB)</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98">高速缓存</a>（cache memory）<ul>
<li>高速缓存行（cache lines）<ul>
<li>通常情况下，大小是64bytes</li>
<li>line 0 -&gt; addr 0-63, line 1 -&gt; addr 64-127, 以此类推</li>
<li>高速缓存命中（cache hit）-&gt; 无需访问内存</li>
</ul>
</li>
<li>L1 cache<ul>
<li>通常在CPU内部</li>
<li>访问L1 cache没有延迟</li>
<li>通常大小是16KB</li>
</ul>
</li>
<li>L2 cache<ul>
<li>访问L2 cache有1-2个时钟周期的延迟</li>
<li>大小在MB级别</li>
</ul>
</li>
<li>因为价格比较贵，所以空间也是很小的</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">主存储器 / 主存</a>（Main memory / RAM -&gt; Random Access Memory）<ul>
<li>曾经叫磁芯储存器（core memory），因为1950s-1960s内存是用可磁化的铁磁体（magnetizable ferrite cores）做的</li>
<li>断电数据就没了</li>
</ul>
</li>
<li>只读储存器（ROM -&gt; Read Only Memory）<ul>
<li>非易失（non-volatile）储存器</li>
<li>速度快而且便宜，但是一次写死不能改</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%8A%B9%E9%99%A4%E5%BC%8F%E5%8F%AF%E8%A4%87%E5%AF%AB%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EEPROM</a>（Electrically Erasable PROM）和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98">闪存</a>（flash memory）<ul>
<li>非易失（non-volatile）储存器</li>
<li>闪存通常作为电子设备的储存介质</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94">CMOS</a>（Complementary Metal-Oxide-Semiconductor）<ul>
<li>易失（volatile）储存器</li>
<li>CMOS保存电脑当前时间日期，以及一些配置参数（例如启动顺序）</li>
<li>CMOS由单独的电池供电</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_9.png" alt=""></p>
<h2 id="Disks"><a href="#Disks" class="headerlink" title="Disks"></a>Disks</h2><p>磁盘（magnetic disk / hard disk）很便宜，但是比内存慢多了</p>
<p>机械硬盘内部长这样：</p>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_10.png" alt=""></p>
<p>机械硬盘的特点：</p>
<ul>
<li>转速：5400, 7200, 10800 RPM</li>
<li>磁道（track）：是盘片上的环形区域（annular region）</li>
<li>柱面（cylinder）：当前磁盘臂位置的所有磁道的集合</li>
<li>扇区（sector）：从磁道划分而来，通常扇区大小为512bytes</li>
</ul>
<p>固态硬盘（SSD -&gt; Solid State Disk）的特点：</p>
<ul>
<li>数据储存在闪存</li>
<li>没有机械结构</li>
</ul>
<h2 id="I-O-Devices"><a href="#I-O-Devices" class="headerlink" title="I/O Devices"></a>I/O Devices</h2><p>I/O设备由两部分组成，分别是设备控制器和设备本身</p>
<p>操作系统通过驱动（device driver）跟设备控制器交互</p>
<p>I/O的方式有三种：</p>
<ul>
<li>忙等待（busy waiting）<ul>
<li>发出system call调用设备，然后循环检查是否完成</li>
<li>缺点：占据CPU直到I/O完成</li>
</ul>
</li>
<li>中断（interrupt）<ul>
<li>设备驱动器通知设备控制器</li>
<li>设备控制器启动对应设备</li>
<li>设备控制器在I/O完成后向中断控制器发信号</li>
<li>中断控制器接收信号后，告知CPU，并把设备编号放到总线上</li>
<li>CPU决定处理中断，把程序计数器和PSW压栈，CPU切换到内核模式</li>
<li>通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7%E5%90%91%E9%87%8F">中断向量</a>（interrupt vector）寻找中断处理程序的地址</li>
<li>开始执行中断处理程序，取走刚刚入栈的程序计数器和PSW，然后查询设备状态</li>
<li>中断处理完成后，返回到用户程序第一条未执行指令</li>
</ul>
</li>
<li>DMA（Direct Memory Access）<ul>
<li>无需CPU干预</li>
<li>处理完成后会引发中断</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_11.png" alt=""></p>
<h2 id="Buses"><a href="#Buses" class="headerlink" title="Buses"></a>Buses</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%80%BB%E7%BA%BF">总线</a>（Bus）是计算机组件交换数据的方式</p>
<p>大型x86系统结构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_12.png" alt=""></p>
<p>几种不同的总线（最下面是最新的技术）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%B8%9A%E6%A0%87%E5%87%86%E7%BB%93%E6%9E%84">ISA</a> (Industry Standard Architecture)</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%AE%BE%E7%BB%84%E4%BB%B6%E4%BA%92%E8%BF%9E%E6%A0%87%E5%87%86">PCI</a> (Peripheral Component Interconnect)</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCIe</a> (Peripheral Component Interconnect Express)</li>
</ul>
<p>几种总线架构</p>
<ul>
<li>共享总线架构（shared bus architecture）<ul>
<li>多设备用同一条线传输数据</li>
<li>例子：ISA, PCI</li>
</ul>
</li>
<li>并行总线架构（shared bus architecture）<ul>
<li>一次可以发送多位数据</li>
<li>例子：ISA, PCI</li>
</ul>
</li>
<li>串行总线架构（serial bus architecture）<ul>
<li>通过单个数据通路（lane）发送所有数据</li>
<li>跟并行总线架构相比，无需保证数据同时到达</li>
<li>例子：PCIe</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E5%AA%92%E9%AB%94%E4%BB%8B%E9%9D%A2">DMI</a> (Direct Media Interface)：连接<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%97%E6%A1%A5">南桥芯片</a>（Southbridge）和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%97%E6%A1%A5">北桥芯片</a>（Northbridge）</p>
<p>USB (Universal Serial Bus)</p>
<ul>
<li>最初是为了连接慢速I/O设备，例如鼠标键盘</li>
<li>USB 1.0 -&gt; 12 Mbps</li>
<li>USB 2.0 -&gt; 480 Mbps</li>
<li>USB 3.0 -&gt; 5 Gbps</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">SCSI</a> (Small Computer System Interface)</p>
<ul>
<li>跟周边设备（例如：硬盘、软驱、光驱、打印机、扫描仪等）通信</li>
<li>通常在服务器和工作站能看到</li>
<li>传输速率：640 MB/s</li>
</ul>
<p>即插即用（plug and play）</p>
<ul>
<li>系统自动收集I/O设备信息</li>
<li>集中赋予中断级别和I/O地址</li>
</ul>
<h2 id="Booting-the-Computer"><a href="#Booting-the-Computer" class="headerlink" title="Booting the Computer"></a>Booting the Computer</h2><p>BIOS (Basic Input Output System)</p>
<ul>
<li>在主板（motherboard）上</li>
<li>包含一些低级I/O软件（例如：读取键盘，写屏幕）</li>
<li>储存在闪存（flash RAM）中</li>
<li>操作系统可以更新BIOS</li>
</ul>
<p>计算机启动过程：</p>
<ul>
<li>BIOS开始运行</li>
<li>通过扫描各类总线，检测安装的内存数量，以及各类基本设备和外设</li>
<li>根据CMOS中的设备清单来决定启动的设备（从光驱，硬盘，USB）</li>
<li>启动设备的第一个扇区被读入内存执行，然后找出活动的（active）分区</li>
<li>从该分区读取第二个启动装载模块（bootloader）</li>
<li>这个bootloader从活动分区读取并启动操作系统</li>
<li>操作系统检查硬件是否都有驱动程序，然后把驱动程序载入内核</li>
<li>初始化分页表，创建一系列后台进程，启动GUI</li>
</ul>
<h1 id="The-Operating-System-Zoo"><a href="#The-Operating-System-Zoo" class="headerlink" title="The Operating System Zoo"></a>The Operating System Zoo</h1><h2 id="Mainframe-Operating-Systems"><a href="#Mainframe-Operating-Systems" class="headerlink" title="Mainframe Operating Systems"></a>Mainframe Operating Systems</h2><p>大型机操作系统主要提供三类服务：</p>
<ul>
<li>批处理（batch）<ul>
<li>处理无需人工干预的周期性任务（processes routine jobs without any interactive user present）</li>
</ul>
</li>
<li>事务处理（transaction processing）<ul>
<li>处理大量的小型请求（handle large numbers of small requests）</li>
</ul>
</li>
<li>分时（timesharing）<ul>
<li>允许多个远程用户同时使用（allow multiple remote users to run jobs）</li>
</ul>
</li>
</ul>
<h2 id="Server-Operating-Systems"><a href="#Server-Operating-Systems" class="headerlink" title="Server Operating Systems"></a>Server Operating Systems</h2><p>服务器操作系统通常在作为服务器的PC，工作站，以及大型机跑</p>
<p>典型的服务器操作系统有：Solaris, FreeBSD, Linux, Windows Server 201x</p>
<h2 id="Multiprocessor-Operating-Systems"><a href="#Multiprocessor-Operating-Systems" class="headerlink" title="Multiprocessor Operating Systems"></a>Multiprocessor Operating Systems</h2><p>多处理器操作系统可以整合大量算力，可以细分为：parallel computers, multicomputers, multiprocessors</p>
<h2 id="Personal-Computer-Operating-Systems"><a href="#Personal-Computer-Operating-Systems" class="headerlink" title="Personal Computer Operating Systems"></a>Personal Computer Operating Systems</h2><p>常用的个人电脑操作系统：</p>
<ul>
<li>Linux</li>
<li>FreeBSD</li>
<li>Windows 7/8/10</li>
<li>OS X</li>
</ul>
<h2 id="Handheld-Computer-Operating-Systems"><a href="#Handheld-Computer-Operating-Systems" class="headerlink" title="Handheld Computer Operating Systems"></a>Handheld Computer Operating Systems</h2><p>掌上计算机，又称为PDA (Personal Digital Assistant)，例如：手机，平板</p>
<p>目前掌上计算机操作系统有：Android, iOS</p>
<h2 id="Embedded-Operating-Systems"><a href="#Embedded-Operating-Systems" class="headerlink" title="Embedded Operating Systems"></a>Embedded Operating Systems</h2><p>嵌入式操作系统一般是在控制设备的计算机允许，通常不允许安装软件</p>
<p>嵌入式例子：微波炉，汽车，MP3播放器等等</p>
<p>常见的嵌入式操作系统：</p>
<ul>
<li>嵌入式Linux</li>
<li>QNX</li>
<li>VxWorks</li>
</ul>
<h2 id="Sensor-Node-Operating-Systems"><a href="#Sensor-Node-Operating-Systems" class="headerlink" title="Sensor-Node Operating Systems"></a>Sensor-Node Operating Systems</h2><p>传感器节点操作系统有多种用途，例如保卫国界，降水测量，森林火灾探测等等</p>
<p>常见的传感器节点操作系统：TinyOS</p>
<h2 id="Real-Time-Operating-Systems"><a href="#Real-Time-Operating-Systems" class="headerlink" title="Real-Time Operating Systems"></a>Real-Time Operating Systems</h2><p>实时操作系统分两类：</p>
<ul>
<li>硬实时系统（hard real-time system）<ul>
<li>必须在限定时间内进行操作</li>
<li>通常用于工控领域，民航领域等等</li>
</ul>
</li>
<li>软实时系统（soft real-time system）<ul>
<li>可以偶尔违反时限，并且不会带来严重后果</li>
<li>通常用于数字音频，智能手机等等</li>
</ul>
</li>
</ul>
<p>实时操作系统这个分类，跟嵌入式系统和掌上计算机操作系统有一定的重叠</p>
<p>常见的实时操作系统：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ECOS">eCos</a></p>
<h2 id="Smart-Card-Operating-Systems"><a href="#Smart-Card-Operating-Systems" class="headerlink" title="Smart Card Operating Systems"></a>Smart Card Operating Systems</h2><p>智能卡操作系统跑在信用卡大小的卡片上</p>
<p>两种主要供电方式：</p>
<ul>
<li>直接接触读卡器供电（contacts in the reader）</li>
<li>接近读卡器，感应供电（inductively powered）</li>
</ul>
<p>部分智能卡使用了Java，因此带有Java虚拟机（JVM）</p>
<h1 id="Operating-System-Concepts"><a href="#Operating-System-Concepts" class="headerlink" title="Operating System Concepts"></a>Operating System Concepts</h1><h2 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h2><p>进程（Processes）-&gt; 正在执行的程序</p>
<p>地址空间（address space）</p>
<ul>
<li>进程可以进行读写的地方</li>
<li>包含可执行程序，程序数据，堆栈（stack）</li>
</ul>
<p>进程表（process table）</p>
<ul>
<li>储存了所有进程的信息</li>
<li>通常是数组或者链表结构</li>
</ul>
<p>挂机的进程（suspended process）包括：</p>
<ul>
<li>地址空间，又叫磁芯映像 / 核心映像（core image）</li>
<li>对应的进程表项</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E6%A0%91">进程树</a>（process tree）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B">父进程</a>（parent process）</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E8%BF%9B%E7%A8%8B">子进程</a>（child process）</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通信</a>（interprocess communication）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_13.png" alt=""></p>
<p>UID (User IDentification)</p>
<ul>
<li>每个用户都有一个UID</li>
<li>同一用户启动的所有进程都会有相同的UID</li>
<li>子进程的UID跟父进程一样</li>
<li>superuser(UNIX) / Administrator(Windows)<ul>
<li>作为系统的超级用户或管理员，拥有很高的权限，可以无视很多规则</li>
</ul>
</li>
</ul>
<p>GID (Group IDentification)</p>
<ul>
<li>用户可以是组员</li>
<li>每个组都有一个GID</li>
</ul>
<h2 id="Address-Spaces"><a href="#Address-Spaces" class="headerlink" title="Address Spaces"></a>Address Spaces</h2><p>内存地址是32位或者64位</p>
<p>如果内存超了，操作系统会调用虚拟内存（virtual memory）</p>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>目录（directory）-&gt; 可以把文件分组存放</p>
<p>根目录（root directory）-&gt; 目录的顶部</p>
<p>路径名（path name）</p>
<ul>
<li>绝对路径（absolute path）</li>
<li>相对路径（relative path）</li>
<li>路径有两种写法：<ul>
<li>/ (slash, UNIX)</li>
<li>\ (backslash, Windows)</li>
</ul>
</li>
</ul>
<p>工作目录（working directory）-&gt; 进程工作的目录，可以被改变</p>
<p>尝试打开文件：</p>
<ul>
<li>如果允许访问，会返回文件描述符（file descriptor），是一个小整数</li>
<li>如果拒绝访问，会返回错误码</li>
</ul>
<p>挂载（mount）机制 (UNIX)</p>
<ul>
<li>可以把外部的文件数接到根文件系统上（root file system）</li>
<li>下图是挂载CD-ROM</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_15.png" alt=""></p>
<p>特殊文件（special file）</p>
<ul>
<li>UNIX一切皆文件</li>
<li>block special files（例如：磁盘）</li>
<li>character special files（例如：打印机，调制器等）</li>
<li>特殊文件保存在/dev<ul>
<li>例如：/dev/lp是打印机</li>
</ul>
</li>
</ul>
<p>管道（pipe）</p>
<ul>
<li>用于连接两个进程</li>
<li>进程A把管道当成普通的输出文件</li>
<li>进程B把管道当成普通的输入文件</li>
</ul>
<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h2><p>常见I/O设备有：键鼠，显示器，打印机等等</p>
<h2 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h2><p>rwx bits</p>
<ul>
<li>r -&gt; read = 4</li>
<li>w -&gt; write = 2</li>
<li>x -&gt; execute = 1</li>
<li>rwxr-x–x = 751 -&gt; owner rwx, other group rx, everyone else x</li>
</ul>
<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><p>提示符（prompt）</p>
<p>Shell有很多种：sh, csh, ksh, bash</p>
<p>标准输出重定向【&gt;】（stdout redirect）：date &gt; file</p>
<p>标准输入重定向【&lt;】（stdin redirect）：sor t &lt; file1 &gt; file2</p>
<p>管道【|】（pipe）：cat file1 file2 file3 | sort &gt; /dev/lp</p>
<p>不等待执行结束【&amp;】（give prompt immediately）：cat file1 file2 file3 | sort &gt; /dev/lp &amp;</p>
<h2 id="Ontogeny-Recapitulates-Phylogeny"><a href="#Ontogeny-Recapitulates-Phylogeny" class="headerlink" title="Ontogeny Recapitulates Phylogeny"></a>Ontogeny Recapitulates Phylogeny</h2><p>标题一个词都不认识哎。。。</p>
<ul>
<li>Ontogeny -&gt; 个体发生学</li>
<li>Recapitulates -&gt; 重复（(BIOLOGY) repeat (an evolutionary or other process) during development and growth）</li>
<li>Phylogeny -&gt; 系统发育学</li>
<li>标题意思：个体重复系统发育</li>
<li>人话：新的产品种类总是容易重蹈覆辙</li>
</ul>
<p>核心观点：当前过时的东西，过几年因为技术的发展可能又在新的产品种类上复活了</p>
<ul>
<li>解释器（interpreter） vs. 直接执行（direct execution）</li>
<li>汇编 vs. 高级语言</li>
<li>单道程序处理（monoprogramming） vs. 多道程序处理（multiprogramming）</li>
</ul>
<h1 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h1><p>count = read(fd, buffer, nbytes);</p>
<ul>
<li>fd -&gt; 指定文件</li>
<li>buffer -&gt; 指向缓冲区</li>
<li>nbytes -&gt; 要读的字节数</li>
<li>count -&gt; 实际读到的字节数，由系统调用返回。如果出错，count = -1</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_17.png" alt=""></p>
<p>POSIX大约有100个过程调用（procedure calls），绝大部分POSIX过程都会触发系统调用</p>
<p>下面是一些主要的POSIX系统调用</p>
<table>
<thead>
<tr>
<th>Process management</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Call</td>
<td>Description</td>
</tr>
<tr>
<td>pid = fork()</td>
<td>Create a child process identical to the parent</td>
</tr>
<tr>
<td>pid = waitpid(pid, &amp;statloc, options)</td>
<td>Wait for a child to terminate</td>
</tr>
<tr>
<td>s = execve(name, argv, environp)</td>
<td>Replace a process’ core image</td>
</tr>
<tr>
<td>exit(status)</td>
<td>Terminate process execution and return status</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>File management</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Call</td>
<td>Description</td>
</tr>
<tr>
<td>fd = open(file, how, …)</td>
<td>Open a file for reading, writing, or both</td>
</tr>
<tr>
<td>s = close(fd)</td>
<td>Close an open file</td>
</tr>
<tr>
<td>n = read(fd, buffer, nbytes)</td>
<td>Read data from a file into a buffer</td>
</tr>
<tr>
<td>n = write(fd, buffer, nbytes)</td>
<td>Write data from a buffer into a file</td>
</tr>
<tr>
<td>position = lseek(fd, offset, whence)</td>
<td>Move the file pointer</td>
</tr>
<tr>
<td>s = stat(name, &amp;buf)</td>
<td>Get a file’s status information</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Directory- and file-system management</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Call</td>
<td>Description</td>
</tr>
<tr>
<td>s = mkdir(name, mode)</td>
<td>Create a new directory</td>
</tr>
<tr>
<td>s = rmdir(name)</td>
<td>Remove an empty directory</td>
</tr>
<tr>
<td>s = link(name1, name2)</td>
<td>Create a new entry, name2, pointing to name1</td>
</tr>
<tr>
<td>s = unlink(name)</td>
<td>Remove a directory entry</td>
</tr>
<tr>
<td>s = mount(special, name, flag)</td>
<td>Mount a file system</td>
</tr>
<tr>
<td>s = umount(special)</td>
<td>Unmount a file system</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Miscellaneous</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Call</td>
<td>Description</td>
</tr>
<tr>
<td>s = chdir(dirname)</td>
<td>Change the working directory</td>
</tr>
<tr>
<td>s = chmod(name, mode)</td>
<td>Change a file’s protection bits</td>
</tr>
<tr>
<td>s = kill(pid, signal)</td>
<td>Send a signal to a process</td>
</tr>
<tr>
<td>seconds = time(&amp;seconds)</td>
<td>Get the elapsed time since Jan. 1, 1970</td>
</tr>
</tbody></table>
<h2 id="System-Calls-for-Process-Management"><a href="#System-Calls-for-Process-Management" class="headerlink" title="System Calls for Process Management"></a>System Calls for Process Management</h2><p>Fork</p>
<ul>
<li>是在POSIX中创建进程的唯一途径</li>
<li>子进程在创建的时候跟父进程一模一样</li>
<li>任何后续变化都不会互相影响</li>
<li>Fork的返回值，在子进程中是0，在父进程中等于子进程的PID (Process IDentifier)。这也是区分父进程和子进程的方法。</li>
</ul>
<p>waitpid</p>
<ul>
<li>等待任意一个子进程终止</li>
<li>可以指定等待特定的子进程，或者是等待老的子进程（参数pid = -1）</li>
<li>waitpid完成时，statloc会被赋值为子进程的退出状态（exit status）</li>
</ul>
<p>execve（exec）</p>
<ul>
<li>参数<ul>
<li>name -&gt; the name of the file to be executed</li>
<li>argv -&gt; a pointer to the argument array</li>
<li>environp -&gt; a pointer to the environment array</li>
</ul>
</li>
<li>替换进程的核心映像（core image）</li>
<li>变种（可以忽略或者指定参数）：execl, execv, execle</li>
</ul>
<p>exit</p>
<ul>
<li>进程终止执行时使用</li>
<li>exit status范围是0-255（通过waitpid中的statloc返回给父进程）</li>
</ul>
<p>下面是一个高度简化的shell，用以说明fork，waitpid和execve的使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="keyword">while</span> (TRUE) &#123;                              <span class="comment">/* repeat forever */</span></span><br><span class="line">    type_prompt();                          <span class="comment">/* display prompt on the screen */</span></span><br><span class="line">    read_command(command, parameters);      <span class="comment">/* read input from terminal */</span></span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) &#123;                      <span class="comment">/* fork off child process */</span></span><br><span class="line">        <span class="comment">/* Parent code. */</span></span><br><span class="line">        waitpid(−<span class="number">1</span>, &amp;status, <span class="number">0</span>);            <span class="comment">/* wait for child to exit */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Child code. */</span></span><br><span class="line">        execve(command, parameters, <span class="number">0</span>);     <span class="comment">/* execute command */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是cp命令的过程展示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure>
<ul>
<li>shell会fork出一个子进程</li>
<li>子进程找到，执行cp并传入参数</li>
<li>cp程序的入口是main(argc, argv, envp)<ul>
<li>argc(=3) -&gt; 在命令行上，包括程序名字在内的参数数量</li>
<li>argv -&gt; 指向数组的指针（a pointer to an array）<ul>
<li>argv[0] -&gt; “cp”</li>
<li>argv[1] -&gt; “file1”</li>
<li>argv[2] -&gt; “file2”</li>
</ul>
</li>
<li>envp -&gt; 指向环境的指针（a pointer to the environment）<ul>
<li>an array of strings (name = value)</li>
<li>用来传入各种环境变量（environment variables）<ul>
<li>例如：terminal type, home directory name</li>
<li>如果什么都不传入，那envp = 0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>UNIX进程的内存被分为三部分：</p>
<ul>
<li>正文段（text segment）</li>
<li>数据段（data segment）<ul>
<li>向上增长（grows upward）</li>
</ul>
</li>
<li>堆栈段（segment segment）<ul>
<li>向下增长（grows downward）</li>
</ul>
</li>
</ul>
<p>使用malloc可以动态分配内存</p>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_20.png" alt=""></p>
<h2 id="System-Calls-for-File-Management"><a href="#System-Calls-for-File-Management" class="headerlink" title="System Calls for File Management"></a>System Calls for File Management</h2><p>open</p>
<ul>
<li>想要读写文件，必须先打开文件</li>
<li>open参数：<ul>
<li>file -&gt; absolute path / relative path</li>
<li>how<ul>
<li>O_RDONLY -&gt; read</li>
<li>O_WRONLY -&gt; write</li>
<li>O_RDWR -&gt; read and write</li>
<li>O_CREAT -&gt; create</li>
</ul>
</li>
</ul>
</li>
<li>返回的file descriptor可以进行读写操作</li>
<li>最后需要使用close关闭文件</li>
</ul>
<p>read &amp; write</p>
<ul>
<li>fd, buffer, nbytes</li>
<li>返回实际字节数。如果出错，返回-1</li>
</ul>
<p>Lseek</p>
<ul>
<li>移动文件指针</li>
<li>lseek参数：<ul>
<li>fd -&gt; file descriptor</li>
<li>offset -&gt; file position</li>
<li>whence -&gt; position type<ul>
<li>相对文件开头</li>
<li>当前位置</li>
<li>相对文件末尾</li>
</ul>
</li>
</ul>
</li>
<li>返回指针移动后，在文件中的绝对位置</li>
</ul>
<p>stat</p>
<ul>
<li>获取文件相关信息<ul>
<li>文件类型（普通文件，特殊文件，目录等）</li>
<li>大小</li>
<li>最后修改时间</li>
<li>若干其它信息</li>
</ul>
</li>
</ul>
<h2 id="System-Calls-for-Directory-Management"><a href="#System-Calls-for-Directory-Management" class="headerlink" title="System Calls for Directory Management"></a>System Calls for Directory Management</h2><p>mkdir -&gt; 创建空目录</p>
<p>rmdir -&gt; 删除空目录</p>
<p>link（链接）</p>
<ul>
<li>创建一个同步的链接，用以共享文件</li>
<li>两个路径都指向同一个文件</li>
<li>i-nodes表记载了文件的相关信息</li>
<li>i-number是i-nodes的引用，UNIX通过i-number来标识文件</li>
<li>link的本质就是，创建新目录，但是使用原有文件的i-number</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_21.png" alt=""></p>
<p>mount（挂载）</p>
<ul>
<li>用于合并两个文件系统</li>
<li>例子：mount(“/dev/sdb0”, “/mnt”, 0);</li>
<li>取消挂载使用umount</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_22.png" alt=""></p>
<h2 id="Miscellaneous-System-Calls"><a href="#Miscellaneous-System-Calls" class="headerlink" title="Miscellaneous System Calls"></a>Miscellaneous System Calls</h2><p>chdir</p>
<ul>
<li>改变当前工作目录</li>
<li>例子：chdir(“/usr/ast/test”);</li>
</ul>
<p>chmod</p>
<ul>
<li>改变文件权限 / 保护模式</li>
<li>例子：chmod(“file”, 0644);</li>
</ul>
<h2 id="The-Windows-Win32-API"><a href="#The-Windows-Win32-API" class="headerlink" title="The Windows Win32 API"></a>The Windows Win32 API</h2><p>Windows和UNIX的编程模式（programming model）不同：</p>
<ul>
<li>UNIX是系统调用（system call）</li>
<li>Windows是事件驱动（event driven）</li>
</ul>
<p>Win32 API</p>
<ul>
<li>包含数千个调用</li>
<li>部分会触发系统调用，也有一些是在用户空间执行</li>
<li>可以管理窗口，图形，文本，字体，滚动条，对话框，菜单等等</li>
</ul>
<p>下面是一些UNIX系统调用对应的Win32 API</p>
<table>
<thead>
<tr>
<th>UNIX</th>
<th>Win32</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>fork</td>
<td>CreateProcess</td>
<td>Create a new process</td>
</tr>
<tr>
<td>waitpid</td>
<td>WaitForSingleObject</td>
<td>Can wait for a process to exit</td>
</tr>
<tr>
<td>execve</td>
<td>(none)</td>
<td>CreateProcess = fork + execve</td>
</tr>
<tr>
<td>exit</td>
<td>ExitProcess</td>
<td>Terminate execution</td>
</tr>
<tr>
<td>open</td>
<td>CreateFile</td>
<td>Create a file or open an existing file</td>
</tr>
<tr>
<td>close</td>
<td>CloseHandle</td>
<td>Close a file</td>
</tr>
<tr>
<td>read</td>
<td>ReadFile</td>
<td>Read data from a file</td>
</tr>
<tr>
<td>write</td>
<td>WriteFile</td>
<td>Write data to a file</td>
</tr>
<tr>
<td>lseek</td>
<td>SetFilePointer</td>
<td>Move the file pointer</td>
</tr>
<tr>
<td>stat</td>
<td>GetFileAttributesEx</td>
<td>Get various file attributes</td>
</tr>
<tr>
<td>mkdir</td>
<td>CreateDirectory</td>
<td>Create a new directory</td>
</tr>
<tr>
<td>rmdir</td>
<td>RemoveDirectory</td>
<td>Remove an empty directory</td>
</tr>
<tr>
<td>link</td>
<td>(none)</td>
<td>Win32 does not support links</td>
</tr>
<tr>
<td>unlink</td>
<td>DeleteFile</td>
<td>Destroy an existing file</td>
</tr>
<tr>
<td>mount</td>
<td>(none)</td>
<td>Win32 does not support mount</td>
</tr>
<tr>
<td>umount</td>
<td>(none)</td>
<td>Win32 does not support mount, so no umount</td>
</tr>
<tr>
<td>chdir</td>
<td>SetCurrentDirectory</td>
<td>Change the current working directory</td>
</tr>
<tr>
<td>chmod</td>
<td>(none)</td>
<td>Win32 does not support security (although NT does)</td>
</tr>
<tr>
<td>kill</td>
<td>(none)</td>
<td>Win32 does not support signals</td>
</tr>
<tr>
<td>time</td>
<td>GetLocalTime</td>
<td>Get the current time</td>
</tr>
</tbody></table>
<p>CreateProcess -&gt; Windows有进程层次，但并非是关系较强的父子链，创建进程后两者是平等的</p>
<h1 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating System Structure"></a>Operating System Structure</h1><h2 id="Monolithic-Systems"><a href="#Monolithic-Systems" class="headerlink" title="Monolithic Systems"></a>Monolithic Systems</h2><p>单体系统（Monolithic System）</p>
<ul>
<li>整个操作系统在内核态以单一程序的方式运行</li>
<li>可以高效的任意调用procedure</li>
<li>任意一个procedure出问题，整个系统就会崩溃</li>
<li>基本结构如下：<ul>
<li>main procedure</li>
<li>service procedure</li>
<li>utility procedure</li>
</ul>
</li>
<li>系统支持载入扩展（extension）<ul>
<li>共享库（shared library, UNIX）</li>
<li>动态链接库（DLL -&gt; Dynamic-Link Library, Windows）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_24.png" alt=""></p>
<h2 id="Layered-Systems"><a href="#Layered-Systems" class="headerlink" title="Layered Systems"></a>Layered Systems</h2><p>THE系统是首个层次式系统（Layered System）</p>
<ul>
<li>1968年，由E. W. Dijkstra在Technische Hogeschool Eindhoven搭建</li>
<li>是为荷兰的计算机Electrologica X8设计的批处理系统</li>
<li>上层无需关心底层的实现</li>
</ul>
<p>THE系统的层次如下：</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>The operator</td>
</tr>
<tr>
<td>4</td>
<td>User programs</td>
</tr>
<tr>
<td>3</td>
<td>Input/output management</td>
</tr>
<tr>
<td>2</td>
<td>Operator-process communication</td>
</tr>
<tr>
<td>1</td>
<td>Memory and drum management</td>
</tr>
<tr>
<td>0</td>
<td>Processor allocation and multiprogramming</td>
</tr>
</tbody></table>
<h2 id="Microkernels"><a href="#Microkernels" class="headerlink" title="Microkernels"></a>Microkernels</h2><p>微内核（Microkernel）</p>
<ul>
<li>把操作系统分成若干模块</li>
<li>只有微内核运行在内核态，其它模块作为用户进程运行</li>
<li>模块崩溃不会造成整个系统的崩溃</li>
<li>常见的现代操作系统只有OS X使用微内核（Mach microkernel）</li>
<li>微内核因为高度可靠，常见于实时、工业、航天、军事等领域</li>
<li>常见的微内核有：Integrity, K42, L4, PikeOS, QNX, Symbian, MINIX 3</li>
</ul>
<p>MINIX 3的微内核由12000行左右的C代码和1400行左右的汇编（用于捕获中断，切换进程等）构成</p>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_26.png" alt=""></p>
<p>MINIX处于用户态的层次：</p>
<ul>
<li>device drivers<ul>
<li>没有I/O的物理访问权</li>
<li>使用kernel call来让内核代为完成I/O行为</li>
</ul>
</li>
<li>servers<ul>
<li>能够完成操作系统的多数工作</li>
<li>再生服务器（reincarnation server）<ul>
<li>负责检查其它servers和drivers是否正常工作</li>
<li>如果发现错误，会自行修复，无需用户干预</li>
</ul>
</li>
</ul>
</li>
<li>user programs<ul>
<li>需要给servers发送短消息请求POSIX系统调用</li>
</ul>
</li>
</ul>
<h2 id="Client-Server-Model"><a href="#Client-Server-Model" class="headerlink" title="Client-Server Model"></a>Client-Server Model</h2><p>客户端（client）构造消息，发给服务端（server），服务端完成工作并发送回应。例如：客户端请求Web页面，服务端返回对应的页面数据。</p>
<h2 id="Virtual-Machines"><a href="#Virtual-Machines" class="headerlink" title="Virtual Machines"></a>Virtual Machines</h2><p>虚拟机在本书的第七章<a href="https://oscarcx123.github.io/%E6%8A%80%E6%9C%AF/virtualization-and-the-cloud.html">Virtualization and the Cloud</a>有做详细介绍</p>
<p>CMS (Conversational Monitor System) -&gt; a single-user, interactive<br>system</p>
<h3 id="The-Java-Virtual-Machine"><a href="#The-Java-Virtual-Machine" class="headerlink" title="The Java Virtual Machine"></a>The Java Virtual Machine</h3><p>JVM (Java Virtual Machine)</p>
<ul>
<li>Java编译器为JVM生成代码</li>
<li>有JVM解释器的地方，就能执行代码</li>
<li>代码在保护环境下隔离执行，不会造成破坏</li>
</ul>
<h2 id="Exokernels"><a href="#Exokernels" class="headerlink" title="Exokernels"></a>Exokernels</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Exokernel">外核</a>（exokernel）</p>
<ul>
<li>负责给虚拟机分配独占的资源（每个虚拟机仅获得一部分资源）</li>
<li>省去了一层映射</li>
</ul>
<h1 id="The-World-According-to-C"><a href="#The-World-According-to-C" class="headerlink" title="The World According to C"></a>The World According to C</h1><h2 id="The-C-Language"><a href="#The-C-Language" class="headerlink" title="The C Language"></a>The C Language</h2><p>显式指针（explicit pointer）</p>
<ul>
<li>指针是指向（包含对象的地址）一个变量或数据结构的变量</li>
<li>理论上，指针是有类型的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1, c2, *p;</span><br><span class="line">c1 = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">p = &amp;c1;    <span class="comment">/* 把c1的地址赋值给指针变量p */</span></span><br><span class="line">c2 = *p;    <span class="comment">/* 把p指向的变量（c1）的内容赋值给c2 */</span></span><br><span class="line"><span class="comment">/* 此时c2 == &#x27;c&#x27; */</span></span><br></pre></td></tr></table></figure>

<p>C语言没有内建字符串（string）、线程（thread）、包（package）、类（class）、对象（object）、类型安全（type safety）、垃圾回收（garbage collection）等</p>
<h2 id="Header-Files"><a href="#Header-Files" class="headerlink" title="Header Files"></a>Header Files</h2><ul>
<li>.c -&gt; 代码文件</li>
<li>.h -&gt; 头文件</li>
</ul>
<p>头文件可以声明和定义很多东西，也可以使用一些简单的宏（macros）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 4096</span></span><br><span class="line"><span class="comment">/* 程序中所有的BUFFER_SIZE在编译时都会自动替换为4096 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* macros可以带参数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="comment">/* i = max(j, k+1)在代码中等价于i = (j &gt; k+1 ? j : k+1) */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* macros可以带条件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> X86</span></span><br><span class="line">intel_int_ack();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 如果X86有定义，就调用intel_int_ack() */</span></span><br></pre></td></tr></table></figure>

<h2 id="Large-Programming-Projects"><a href="#Large-Programming-Projects" class="headerlink" title="Large Programming Projects"></a>Large Programming Projects</h2><p>C程序编译过程：</p>
<ul>
<li>C预处理器（C preprocessor）<ul>
<li>处理#include，把内容都加入代码里，然后把结果传给C编译器</li>
</ul>
</li>
<li>通过C编译器生成.o文件（object file）<ul>
<li>object file包含了目标机器的二进制指令</li>
</ul>
</li>
<li>linker把object file组合成一个单一的可执行程序（.out文件）<ul>
<li>任何调用的库（library）在此阶段会被包含进去</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/oscarcx123/hexo_resource/master/img/OS_4e_fig_1_30.png" alt=""></p>
<p>make (UNIX)</p>
<ul>
<li>可以读入Makefile</li>
<li>Makefile写明了文件依赖关系</li>
<li>通过检查object file的变动来决定是否重新编译</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/essay/20200309.html" rel="prev" title="20200309 杂谈">
      <i class="fa fa-chevron-left"></i> 20200309 杂谈
    </a></div>
      <div class="post-nav-item">
    <a href="/essay/20200310.html" rel="next" title="20200310 杂谈">
      20200310 杂谈 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-an-Operating-System"><span class="nav-number">1.</span> <span class="nav-text">What is an Operating System?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Operating-System-as-an-Extended-Machine"><span class="nav-number">1.1.</span> <span class="nav-text">The Operating System as an Extended Machine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Operating-System-as-a-Resource-Manager"><span class="nav-number">1.2.</span> <span class="nav-text">The Operating System as a Resource Manager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#History-of-Operating-Systems"><span class="nav-number">2.</span> <span class="nav-text">History of Operating Systems</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Gen-1-1945%E2%80%9355-Vacuum-Tubes"><span class="nav-number">2.1.</span> <span class="nav-text">Gen 1 (1945–55): Vacuum Tubes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gen-2-1955%E2%80%9365-Transistors-and-Batch-Systems"><span class="nav-number">2.2.</span> <span class="nav-text">Gen 2 (1955–65): Transistors and Batch Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gen-3-1965%E2%80%931980-ICs-and-Multiprogramming"><span class="nav-number">2.3.</span> <span class="nav-text">Gen 3 (1965–1980): ICs and Multiprogramming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gen-4-1980%E2%80%93Present-Personal-Computers"><span class="nav-number">2.4.</span> <span class="nav-text">Gen 4 (1980–Present): Personal Computers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gen-5-1990%E2%80%93Present-Mobile-Computers"><span class="nav-number">2.5.</span> <span class="nav-text">Gen 5 (1990–Present): Mobile Computers</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Computer-Hardware-Review"><span class="nav-number">3.</span> <span class="nav-text">Computer Hardware Review</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Processors"><span class="nav-number">3.1.</span> <span class="nav-text">Processors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Multithreaded-and-Multicore-Chips"><span class="nav-number">3.1.1.</span> <span class="nav-text">Multithreaded and Multicore Chips</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory"><span class="nav-number">3.2.</span> <span class="nav-text">Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Disks"><span class="nav-number">3.3.</span> <span class="nav-text">Disks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-Devices"><span class="nav-number">3.4.</span> <span class="nav-text">I&#x2F;O Devices</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buses"><span class="nav-number">3.5.</span> <span class="nav-text">Buses</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Booting-the-Computer"><span class="nav-number">3.6.</span> <span class="nav-text">Booting the Computer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Operating-System-Zoo"><span class="nav-number">4.</span> <span class="nav-text">The Operating System Zoo</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mainframe-Operating-Systems"><span class="nav-number">4.1.</span> <span class="nav-text">Mainframe Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Server-Operating-Systems"><span class="nav-number">4.2.</span> <span class="nav-text">Server Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multiprocessor-Operating-Systems"><span class="nav-number">4.3.</span> <span class="nav-text">Multiprocessor Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Personal-Computer-Operating-Systems"><span class="nav-number">4.4.</span> <span class="nav-text">Personal Computer Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handheld-Computer-Operating-Systems"><span class="nav-number">4.5.</span> <span class="nav-text">Handheld Computer Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Embedded-Operating-Systems"><span class="nav-number">4.6.</span> <span class="nav-text">Embedded Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sensor-Node-Operating-Systems"><span class="nav-number">4.7.</span> <span class="nav-text">Sensor-Node Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Real-Time-Operating-Systems"><span class="nav-number">4.8.</span> <span class="nav-text">Real-Time Operating Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Smart-Card-Operating-Systems"><span class="nav-number">4.9.</span> <span class="nav-text">Smart Card Operating Systems</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-System-Concepts"><span class="nav-number">5.</span> <span class="nav-text">Operating System Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Processes"><span class="nav-number">5.1.</span> <span class="nav-text">Processes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Address-Spaces"><span class="nav-number">5.2.</span> <span class="nav-text">Address Spaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Files"><span class="nav-number">5.3.</span> <span class="nav-text">Files</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Input-Output"><span class="nav-number">5.4.</span> <span class="nav-text">Input&#x2F;Output</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protection"><span class="nav-number">5.5.</span> <span class="nav-text">Protection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Shell"><span class="nav-number">5.6.</span> <span class="nav-text">The Shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ontogeny-Recapitulates-Phylogeny"><span class="nav-number">5.7.</span> <span class="nav-text">Ontogeny Recapitulates Phylogeny</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-Calls"><span class="nav-number">6.</span> <span class="nav-text">System Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Calls-for-Process-Management"><span class="nav-number">6.1.</span> <span class="nav-text">System Calls for Process Management</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Calls-for-File-Management"><span class="nav-number">6.2.</span> <span class="nav-text">System Calls for File Management</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Calls-for-Directory-Management"><span class="nav-number">6.3.</span> <span class="nav-text">System Calls for Directory Management</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Miscellaneous-System-Calls"><span class="nav-number">6.4.</span> <span class="nav-text">Miscellaneous System Calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Windows-Win32-API"><span class="nav-number">6.5.</span> <span class="nav-text">The Windows Win32 API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-System-Structure"><span class="nav-number">7.</span> <span class="nav-text">Operating System Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Monolithic-Systems"><span class="nav-number">7.1.</span> <span class="nav-text">Monolithic Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Layered-Systems"><span class="nav-number">7.2.</span> <span class="nav-text">Layered Systems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Microkernels"><span class="nav-number">7.3.</span> <span class="nav-text">Microkernels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client-Server-Model"><span class="nav-number">7.4.</span> <span class="nav-text">Client-Server Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Machines"><span class="nav-number">7.5.</span> <span class="nav-text">Virtual Machines</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Java-Virtual-Machine"><span class="nav-number">7.5.1.</span> <span class="nav-text">The Java Virtual Machine</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exokernels"><span class="nav-number">7.6.</span> <span class="nav-text">Exokernels</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-World-According-to-C"><span class="nav-number">8.</span> <span class="nav-text">The World According to C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-C-Language"><span class="nav-number">8.1.</span> <span class="nav-text">The C Language</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Header-Files"><span class="nav-number">8.2.</span> <span class="nav-text">Header Files</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Large-Programming-Projects"><span class="nav-number">8.3.</span> <span class="nav-text">Large Programming Projects</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="oscarcx123"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">oscarcx123</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oscarcx123" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oscarcx123" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oscarcx123</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">162k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:27</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
